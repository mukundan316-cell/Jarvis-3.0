import { db } from "./db";
import { emails, submissions, commercialPropertySubmissions, commercialPropertyWorkflows, activities } from "../shared/schema";
import { eq, and } from "drizzle-orm";
import { emailPipeline } from "./intelligentEmailAgents";

/**
 * Email to Submission Conversion System
 * Converts processed broker emails into submissions for Rachel's underwriting queue
 * Following replit.md principles: NO HARD-CODING, AUDIT TRAIL, MODULAR DESIGN
 */

export class EmailToSubmissionConverter {
  
  /**
   * Convert processed email to submission
   * Called after email pipeline completes processing
   */
  async convertEmailToSubmission(emailId: number, userId: string): Promise<any> {
    console.log(`üîÑ Converting email ${emailId} to submission...`);
    
    try {
      // Get processed email data
      const [email] = await db.select().from(emails).where(eq(emails.id, emailId));
      if (!email || email.processingStatus !== "completed") {
        throw new Error(`Email ${emailId} not ready for conversion (status: ${email.processingStatus})`);
      }

      const extractedIntentData = email.extractedIntentData as any;
      const documentClassification = email.documentClassification as any;
      
      if (!extractedIntentData?.readyForSubmission) {
        console.log(`‚ö†Ô∏è Email ${emailId} not ready for submission - missing required data`);
        return { 
          status: "pending_data", 
          reason: "Insufficient data extracted for automatic submission creation" 
        };
      }

      // Access the nested extractedData structure
      const extractedData = extractedIntentData.extractedData || extractedIntentData;
      
      // Check if already converted to avoid duplicates - use email source and subject as unique identifiers
      const existingSubmission = await db.query.commercialPropertySubmissions.findFirst({
        where: and(
          eq(commercialPropertySubmissions.senderEmail, email.fromEmail),
          eq(commercialPropertySubmissions.subject, email.subject || '')
        )
      });
      
      if (existingSubmission) {
        console.log(`‚úÖ Email ${emailId} already converted to submission ${existingSubmission.submissionId}`);
        return {
          status: "already_converted",
          workflowId: existingSubmission.workflowId,
          submissionId: existingSubmission.submissionId,
          reason: "Email already converted to submission workflow"
        };
      }

      // Generate submission ID using timestamp + broker initials
      const brokerInfo = email.brokerInfo as any;
      const brokerInitials = this.getBrokerInitials(email.fromEmail);
      const submissionId = `${brokerInitials}-${Date.now().toString().slice(-6)}`;

      // Determine if this is a commercial property submission
      const isCommercialProperty = this.isCommercialPropertySubmission(extractedData, documentClassification);

      let submission;
      
      if (isCommercialProperty) {
        // Create Commercial Property submission
        submission = await this.createCommercialPropertySubmission(email, submissionId, extractedData, documentClassification, userId);
      } else {
        // Create general submission
        submission = await this.createGeneralSubmission(email, submissionId, extractedData, userId);
      }

      // Link email to submission
      await db.update(emails).set({ 
        submissionId: submissionId,
        workflowContext: `Auto-generated submission from broker email - ${extractedData.submissionType}`
      }).where(eq(emails.id, emailId));

      // Create activity record - AUDIT TRAIL requirement
      await db.insert(activities).values({
        userId,
        activity: `Submission created from broker email: ${submission.id || submissionId} from ${email.fromEmail}`,
        persona: "rachel",
        status: "completed",
        metadata: JSON.stringify({
          emailId,
          submissionId: submission.id || submissionId,
          submissionType: isCommercialProperty ? "commercial_property" : "general",
          brokerDomain: email.fromEmail.split('@')[1],
          documentsCount: documentClassification?.documentsFound || 0,
          linesOfBusiness: extractedData.linesOfBusiness,
          autoGenerated: true
        })
      });

      console.log(`‚úÖ Submission ${submission.id || submissionId} created from email ${emailId}`);
      
      return {
        status: "converted",
        submission,
        submissionId: submission.id || submissionId,
        submissionType: isCommercialProperty ? "commercial_property" : "general"
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`‚ùå Email to submission conversion failed for ${emailId}:`, error);
      
      // Log conversion failure
      await db.insert(activities).values({
        userId,
        activity: `Failed to convert email ${emailId} to submission: ${errorMessage}`,
        persona: "rachel",
        status: "failed",
        metadata: JSON.stringify({ emailId, error: errorMessage })
      });

      throw error;
    }
  }

  /**
   * Create commercial property submission with full workflow
   */
  private async createCommercialPropertySubmission(email: any, submissionId: string, extractedData: any, documentClassification: any, userId: string) {
    
    // Create commercial property workflow first
    const workflowData = {
      submissionId,
      userId,
      currentStep: 1, // Email Intake completed
      completedSteps: [1], // Mark email intake as complete
      status: "in_progress" as const,
      stepData: JSON.stringify({
        emailIntake: {
          brokerEmail: email.fromEmail,
          insuredBusinessName: extractedData.businessDetails.businessName,
          effectiveDate: extractedData.effectiveDate || "TBD",
          coverageLines: extractedData.linesOfBusiness.join(", "),
          propertyDetails: extractedData.businessDetails.location || "",
          attachments: documentClassification.classifications || {},
          emailSource: email.fromEmail,
          subject: email.subject,
          priority: this.mapPriorityToWorkflow(email.priority)
        }
      })
    };

    const [workflow] = await db.insert(commercialPropertyWorkflows).values(workflowData).returning();

    // Create detailed commercial property submission
    const submissionData = {
      workflowId: workflow.id,
      submissionId,
      // Email intake data
      emailSource: email.fromEmail,
      senderEmail: email.fromEmail,
      subject: email.subject,
      attachmentCount: documentClassification.documentsFound || 0,
      // Document ingestion data
      documentsExtracted: JSON.stringify({
        acordForms: documentClassification.classifications.acordForms || [],
        sovFiles: documentClassification.classifications.sovFiles || [],
        lossRuns: documentClassification.classifications.lossRuns || [],
        photos: documentClassification.classifications.photos || [],
        extractedData: extractedData
      }),
      documentValidationStatus: documentClassification.completenessScore >= 70 ? "validated" : "needs_review",
      // Initial risk data
      enrichmentScore: extractedData.confidence ? (extractedData.confidence / 100).toString() : "0.75",
      appetiteAlignment: this.determineAppetiteAlignment(extractedData),
      // Derived from email content
      riskPropensityScore: parseFloat(this.calculateInitialRiskScore(extractedData)).toString(),
      profitabilityScore: parseFloat(this.calculateProfitabilityScore(extractedData)).toString()
    };

    const [submission] = await db.insert(commercialPropertySubmissions).values([submissionData]).returning();

    console.log(`üè¢ Created commercial property submission: ${submissionId} with workflow ID ${workflow.id}`);
    
    return {
      ...submission,
      workflowId: workflow.id,
      type: "commercial_property"
    };
  }

  /**
   * Create general submission for non-commercial property requests
   */
  private async createGeneralSubmission(email: any, submissionId: string, extractedData: any, userId: string) {
    
    const submissionData = {
      submissionId,
      brokerName: this.extractBrokerName(email.fromEmail),
      clientName: extractedData?.businessDetails?.businessName || email.fromEmail.split('@')[0],
      riskLevel: this.determineRiskLevel(extractedData),
      recommendedLine: (extractedData?.linesOfBusiness || ["Commercial Property"]).join(", "),
      status: "pending" as const,
      assignedTo: "rachel", // Always assign broker emails to Rachel
      details: JSON.stringify({
        emailId: email.id,
        brokerEmail: email.fromEmail,
        extractedData,
        submissionSource: "email_automation",
        linesOfBusiness: extractedData.linesOfBusiness,
        effectiveDate: extractedData.effectiveDate,
        priority: this.mapPriorityToSubmission(email.priority || "normal"),
        coverage: this.extractTotalCoverage(extractedData.coverageAmounts)
      }),
      documentationStatus: "complete",
      actionRequired: "review_automated_submission"
    };

    const [submission] = await db.insert(submissions).values(submissionData).returning();

    console.log(`üìÑ Created general submission: ${submissionId}`);
    
    return {
      ...submission,
      type: "general"
    };
  }

  // Helper methods for submission creation
  private getBrokerInitials(email: string): string {
    const domain = email.split('@')[1];
    if (domain.includes('wtk')) return 'WTK';
    if (domain.includes('aom')) return 'AOM';
    if (domain.includes('acm')) return 'ACM';
    if (domain.includes('doc')) return 'DOC';
    return 'BRK'; // Generic broker
  }

  private isCommercialPropertySubmission(extractedData: any, documentClassification: any): boolean {
    // Commercial property if ACORD forms present OR CP LOB detected
    return (
      documentClassification?.acordFormsDetected === true ||
      extractedData?.linesOfBusiness?.includes("Commercial Property") ||
      extractedData?.submissionType?.includes("commercial_property")
    );
  }

  private mapPriorityToWorkflow(emailPriority: string): string {
    const priorityMap: Record<string, string> = {
      "urgent": "high",
      "high": "high", 
      "normal": "medium",
      "low": "low"
    };
    return priorityMap[emailPriority] || "medium";
  }

  private mapPriorityToSubmission(emailPriority: string): "low" | "medium" | "high" {
    const priorityMap: Record<string, "low" | "medium" | "high"> = {
      urgent: "high",
      high: "high", 
      normal: "medium",
      low: "low"
    };
    return priorityMap[emailPriority] || "medium";
  }
  
  private determineRiskLevel(extractedData: any): string {
    // Determine risk level based on extracted data
    const businessType = extractedData.businessDetails?.businessType;
    const coverageAmount = this.extractTotalCoverage(extractedData.coverageAmounts);
    
    if (businessType === "manufacturing" || coverageAmount > 5000000) return "high";
    if (coverageAmount > 1000000) return "medium";
    return "low";
  }

  private determineAppetiteAlignment(extractedData: any): string {
    // Simple appetite scoring based on extracted data
    const businessType = extractedData.businessDetails?.businessType;
    const hasLossRuns = extractedData.documentsFound > 0;
    const hasProperCoverage = Object.keys(extractedData.coverageAmounts || {}).length > 0;

    if (hasLossRuns && hasProperCoverage && businessType !== "unknown") {
      return "strong";
    } else if (hasProperCoverage) {
      return "moderate";
    } else {
      return "weak";
    }
  }

  private calculateInitialRiskScore(extractedData: any): string {
    // Basic risk scoring - would be enhanced with actual risk models
    let score = 50; // Base score
    
    const businessType = extractedData.businessDetails?.businessType;
    if (businessType === "manufacturing") score += 20; // Higher risk
    if (businessType === "office") score -= 10; // Lower risk
    
    const coverageAmount = this.extractTotalCoverage(extractedData.coverageAmounts);
    if (coverageAmount > 1000000) score += 15; // High value = higher risk
    if (coverageAmount < 100000) score -= 10; // Low value = lower risk

    return Math.max(0, Math.min(100, score)).toString();
  }

  private calculateProfitabilityScore(extractedData: any): string {
    // Simple profitability model
    const coverageAmount = this.extractTotalCoverage(extractedData.coverageAmounts);
    const businessType = extractedData.businessDetails?.businessType;
    
    let score = 60; // Base profitability
    
    if (coverageAmount > 500000) score += 20; // Higher premiums
    if (businessType === "office" || businessType === "retail") score += 10; // Stable businesses
    
    return Math.max(0, Math.min(100, score)).toString();
  }

  private extractBrokerName(email: string): string {
    const domain = email.split('@')[1];
    if (domain.includes('wtk')) return 'WTK Brokers';
    if (domain.includes('aom')) return 'AOM Brokers';
    if (domain.includes('acm')) return 'ACME Brokers';
    if (domain.includes('doc')) return 'DOC Brokers';
    
    // Extract company name from domain
    const companyPart = domain.split('.')[0];
    return companyPart.charAt(0).toUpperCase() + companyPart.slice(1) + ' Brokers';
  }

  private extractTotalCoverage(coverageAmounts: any): number {
    if (!coverageAmounts || typeof coverageAmounts !== 'object') return 0;
    
    const amounts = Object.values(coverageAmounts)
      .filter(amount => typeof amount === 'string' || typeof amount === 'number')
      .map(amount => parseFloat(String(amount).replace(/[^\d.]/g, '')))
      .filter(amount => !isNaN(amount));
    
    return amounts.reduce((sum, amount) => sum + amount, 0);
  }

  /**
   * Process all pending emails for automatic submission conversion
   * Can be called periodically or triggered by new email arrivals
   */
  async processPendingEmails(userId: string): Promise<any[]> {
    console.log("üîÑ Processing pending emails for submission conversion...");
    
    // Get emails that completed processing but haven't been converted to submissions
    const pendingEmails = await db.select().from(emails).where(
      eq(emails.processingStatus, "completed")
    );

    const results = [];
    
    for (const email of pendingEmails) {
      if (!email.submissionId) { // Only process emails not yet converted
        try {
          const result = await this.convertEmailToSubmission(email.id, userId);
          results.push({ emailId: email.id, ...result });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`Failed to process email ${email.id}:`, error);
          results.push({ emailId: email.id, status: "error", error: errorMessage });
        }
      }
    }
    
    console.log(`‚úÖ Processed ${results.length} pending emails`);
    return results;
  }
}

// Export singleton instance
export const emailToSubmissionConverter = new EmailToSubmissionConverter();